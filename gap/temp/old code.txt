

var pos = 0; // position of life
var pos_min = 0; // years for life
var pos_max = 45; // years until the end
var prev_pos = pos; // previous life step

var start_year = curr_date.getFullYear(); // start year
var end_year = start_year + pos_max; // year to end the game
var prev_year = start_year-1; // previous year
var curr_year = start_year; // current year
var diff_step = 244; // gap difference in $
var fdiff = 0; // female money calculated with diff_step based on current year


 if(ingame)
    {    
      //prev_pos = pos;      
      //if(delta < 0 && pos < pos_max) ++pos;
     // else if(delta >= 0 && pos > pos_min) --pos;
     // if(pos != prev_pos) tick();
}


function info()
{
  i = $('<div id="info"></div>').appendTo('#content');
  i.append($('<div class="male">').append('<span class="mdiff">0</span><div class="piggy_happy"></div>').append());
  i.append($('<div class="y"></div>'));
  i.append($('<div class="female">').append('<span class="fdiff">0</span><div class="piggy_unhappy"></div>').append());      
  ticker_init();
}
function ticker_init()
{
  fstart(arguments.callee.name);

  var ticker = $('#info .y');
  var th = 31;
  var opacity_step = 1 / (tick_count + 1);

  for(var i = tick_count; i > 0; --i)
  {
    var item = $('<div class="prev'+i+' prev"></div>').appendTo(ticker);
    item.append('<div class="year"></div>');
    item.append('<div class="mask"></div>'); 
    var tmp = th*(tick_count-i);
    if(tmp != 0) ++tmp;
    item.css({top:tmp,opacity:1-opacity_step*i});

  }
  ticker.append($('<div class="curr"></div>').append('<div class="year"></div>').append('<div class="mask"></div>').css({top:tick_count*th+1}));

  for(var i = 1; i <= tick_count; ++i)
  {
    var item = $('<div class="next'+i+' next"></div>').appendTo(ticker);
    item.append('<div class="year"></div>');
    item.append('<div class="mask"></div>');   
    var tmp = th*(tick_count+i) + 1;

    item.css({top:tmp,opacity:(1-opacity_step*i)});
  }

  ticker.css({ height: th*(tick_count*2+1)});
  ticker.css({ top: h/2-ticker.height()/2-1});

  ticker_tick();
  fend(arguments.callee.name);
}
function ticker_tick()
{
  var ticker = $('#info .y');
  for(var i = 1; i <= tick_count; ++i)
  {
    var prev = ticker.find('.prev'+i);
    if(curr_year-start_year >= i) prev.show();
    else prev.hide();
    prev.find(".year").text(curr_year-i);


    var next = ticker.find('.next'+i);
    if(end_year - curr_year >= i) next.show();
    else next.hide();
    next.find(".year").text(curr_year+i);
  }
  ticker.find('.curr .year').text(curr_year);
}







// function Field(val){
//     var v = val;
   
//     this.__defineGetter__("value", function(){
//         return v;
//     });
   
//     this.__defineSetter__("value", function(val){
//         v = val;
//     });
// }

// pathAnimator.start( speed, step, reverse, startOffset, finish, easing);

// function step( point, angle ){
//   $('#tester').css({
//                     left:point.x*$(document).width()/100+'px',
//                     top:point.y+'px',
//                     transform:"rotate(" + angle + "deg)",
//                     "-webkit-transform":"rotate(" +  angle + "deg)" });
//  // console.log("step",point, angle);
//     // do something every "frame" with: point.x, point.y & angle
// }

// function finish(){
//   //this.stop();
//     // do something when animation is done
// }



// -- checking image loading but for old version with layers and horizontal scrolling
// var imageLoaderCount = 0;
// var imageLoadedCount = 0;
// function app_validity_check()
// {
//   for(var i = 0; i < stages.length; ++i)
//   {
//     var bk = 0;
//     var layer = stages[i].layers;
//     imageLoaderCount += layer.length;
//     for(var j = 0; j < layer.length; ++j)
//     {     
//       if(layer[j].type == 1) ++bk;
//     }
//     if(bk != 1) {
//       throw { name: 'FatalError', message: 'Something went badly wrong' };
//       console.error('Each stage have only one layer with type 1(background)'); 
//     }
//   }
// }


// app_validity_check();



// var bk_offset = 0;
// var bk_offset_prev = 0;
// var last_image_width = 0;
// var stage_index = 0;
// var layer_index = 0;
// // var new_stage = true;
// var stage_first = true;
// var img_scaler = 1;
// var bg_i = 1;
// var fg_i = 1;
// function top_stage_draw()
// {

//   var tmp = null; 
//   var bg = $('.top .stage .layer.bg');
//   var fg = $('.top .stage .layer.fg');

  
//   //var init_img_height = bg_image.height();
//   // img_scaler =  img.height() / init_img_height ;
//   // var layers = stages[stage_index].layers; 

//   // if(layer_index == layers.length && stage_index+1==stages.length) { current_path_width = $('.stage .layer.bg img').width(); return; }

//   //   //console.log(layers,layer_index,stage_index,stages.length);  
//   //   //console.log('layer_index',layer_index, 'layers.length',layers.length, 'stage_index',stage_index, 'stage.length',stages.length);
//   //   //console.log(stage_first , (layer_index == layers.length ),  stage_index != stages.length , stage_index <= stages.length-1);
//   // var layer = fg;
//   // var index = fg_i;
//   // if(stage_first || (layer_index == layers.length && stage_index <= stages.length-1))
//   // {      
//   //   if(!stage_first) ++stage_index;
//   //   layer_index = 0;
//   //   layers =  stages[stage_index].layers;     
//   //   stage_first = false;
//   //   layer = bg;
//   //   index = bg_i++;
//   // }
//   // else ++fg_i;
//   // var li = layer_index++;
//   // var l = layers[li];
//   // l.i = li+1;

//   // var img = $('<img src="'+l.image+'"/>');
//   // layer.append($('<div class="part" data-part-id="'+index+'"></div>').css('z-index', 20).append(img));
//   // img.data(l);

//   // img.load( l.type == 1 ? image_background : image_object );

// };

// function image_background()
// {
//     var img = $(this);
//     var init_img_height = img.height();

//     bk_offset+=bk_offset_prev;        
//    // var l = img.data();
//  //   console.log(l);
//     //console.log(img,img.length,"asdfsdf",bk_offset_prev,bk_offset,(bk_offset + v.position.x*w/100), v.position.y*lh/100 );

//     img.css({ 
//       height:lh, 
//       left: (bk_offset),
//       top:0 
//     });
//     last_image_width=bk_offset_prev=img.width();     

//     img_scaler =  img.height() / init_img_height ;
//     stages[stage_index].w = img.width();

//   ++imageLoadedCount;  
//   progress(Math.ceil10(imageLoadedCount*100/imageLoaderCount));

//   top_stage_draw();
// }
// function image_object()
// {
//   var img = $(this);
//   var l = img.data();

//   var wtmp = (exist(l.fullscreen) && l.fullscreen) ? w : last_image_width;      
//   img.css({ height:img.height()*img_scaler });
//   //console.log('image_object',l,wtmp);
//   img.parent('.part').css({ 
//     left:bk_offset + l.position.x*wtmp/100-img.width()/2,
//     top: Math.abs((100-l.position.y)*lh/100 - img.height()) });

//   ++imageLoadedCount;
//   progress(Math.ceil10(imageLoadedCount*100/imageLoaderCount));
//   //console.log(Math.ceil10(imageLoadedCount*100/imageLoaderCount));

//   top_stage_draw();
// }




// function collision(v)
// {
//   //var cleft = $('.m.character').position().left;
//   //var cright = cleft + $('.m.character').width();  
//   var pleft = $('.layer.fg .part[data-part-id=1] img').parent().position().left;
//   var pright = pleft + $('.layer.fg .part[data-part-id=1] img').parent().width();
//   //console.log("---------------------------",timeline_scroll_to_tick_value,timeline_scroll_to_tick_value+v);
//   var percent = ((timeline_scroll_to_tick_value+v)%timeline_scroll_to_tick)*100/timeline_scroll_to_tick;
//   //console.log("collision ------------", percent);
//   var coord = pathCoordinateByPercent(percent);  

//   var pos = male.lookinfuture(coord);
// //  console.log("------------------------__",pos,v);

//   var cleft = pos.x;
//   var cright = pos.x + $('.m.character').width();
//   //console.log(cleft,cright,pleft,pright);


//   //if((cleft >= pleft && cleft <= pright) || (cright >= pleft && cright <= pright))
//   if(cleft >= pleft && cright <= pright)
//   { 
//     //console.log('colission detector inside');
//     if(!male.inside)
//     {
//       //console.log('colissing shrinking');
//       transform.transform('scale', '.m.character', { x:0.5,y:0.5 });  
//       male.inside = true;
//     //  console.log("inside");
//       //console.log("-------------------------------------------duf");
//     }
//   }
//   else if(male.inside)
//   {
//     //console.log('colissing to default');
//     male.inside = false;
//     //console.log('rescaling to default');
//     transform.transform('scale', '.m.character', { x:2,y:2 });  
//   }
// }



  //function screen(v){ cur_screen = v; }
  //function nexts(){ screen(++curr_screen); }
  //function prevs(){ screen(--curr_screen); } 





















  

//function calculate(){
  // var life = (max_age - user.age) * 12;
  // var tickCount = (life / time_step_number) * timeline_scroll_to_tick;
  // var lifePercent = (timeline_scroll_to_tick_value*100)/tickCount;
  // stage_id = Math.floor10(timeline_scroll_to_tick_value/timeline_scroll_to_tick)%1;


  //pathSwitch(stages[stage_id].layers[0].path);

  //if(stage_id != prev_stage_id)
  //{
  //  stage_offset = 0;
  //  for(var i = 1; i <= stage_id; ++i)
  //    stage_offset += stages[i].w;  
  //}

  //console.log(stage_id);
  //var percent = (timeline_scroll_to_tick_value%timeline_scroll_to_tick)*100/timeline_scroll_to_tick;
  //  console.log("not collision ------------", percent);
  //var coord = pathCoordinateByPercent(percent);  

  //var coord = pathCoordinateByPercent(lifePercent*8);
  //redraw_human(coord);
//}



/*
function pathSwitch(v)
{
  path.setAttribute('d', v);    
  pathl = path.getTotalLength();
}
function pathCoordinateByPercent(percent) // input percent of whole path
{
  var p1 = pointAt(percent-1);
  var p2 = pointAt(percent+1);
  var a = Math.atan2(p2.y-p1.y,p2.x-p1.x)*180 / Math.PI;
  var p = pointAt(percent);  
  return { x:p.x,y:p.y, a:a };
}      
function pointAt(p){

    return path.getPointAtLength( pathl * p/100 );
}


function getPathCoordinateByPercent(path,pathl,percent) // input percent of whole path
{
  var p1 = path.getPointAtLength(pathl * (percent-1)/100);
  var p2 = path.getPointAtLength(pathl * (percent+1)/100);
  var a = Math.atan2(p2.y-p1.y,p2.x-p1.x)*180 / Math.PI;
  var p =  path.getPointAtLength(pathl * (percent/100);
  return { x:p.x,y:p.y, a:a };
}      
*/




// 03.10.2014 changed to be pos and new time calculations
      // if(v==1)
      // {  
      //   ++timeline_scroll_to_tick_value;
      //   var t1 = (timeline_period_w)/timeline_scroll_to_tick * (timeline_scroll_to_tick_value + 1) + w;
       
      //   var len = timeline_points.length;
      //   if(t1 > len*timeline_period_w) 
      //   {
      //     var toadd = Math.round10(t1/(timeline_period_w)) + 1 - len;
      //      timeline_tick(time_step,toadd);
      //   }          
      // }
      // else 
      // {
      //   if(timeline_scroll_to_tick_value > 0)
      //   {
          
      //     --timeline_scroll_to_tick_value;    
      //   }
      // }
      //  //$('.canvas').css({left:-timeline_scroll_to_tick_value* (w*timeline_scale/timeline_scroll_to_tick)});
      //$('.treasure .red-carpet').css({left:-timeline_scroll_to_tick_value* (w*timeline_scale/timeline_scroll_to_tick)});

variable refactoring plus no need some code anymore, month format wasn't used anywhere so deleted
      function timeline_tick(n)
{
  /*if(exist(v))
  {    
    if(typeof v === "number") v = Math.round10(v);
    if(typeof v === "string" && v.length >= 2 && v.match(/[my]/g).length == 1) 
    {
      if(v.indexOf('m') != -1) 
      {
        v = v.replace('m','');
        if(isNumberWithSign(v)) v=+v;
      }
      else if(v.indexOf('y') != -1)
      {
        v = v.replace('y','');
        if(isNumberWithSign(v)) v=+v*12; 
      }
    }
  }*/
  //if(isNumberWithSign(v)) 
  //{  
    for(var i = 0; i < n; ++i)
    {
      var curTime = new Date();
      size = timeline_points.length;
      curTime.setTime(timeline_points[size-1].getTime());

      curTime.setMonth(curTime.getMonth() + reward_period);

      if(curTime > timeline_end_point) epilogue();

      timeline_point = curTime;
      timeline_points.push(curTime);  
    }      
    timeline_point_draw(reward_period);  
  //}
  else console.log("timeline step is incorrect");  
  
}




function timeline_point_draw()
      //   for(var j = i*reward_period-1; j >= i*reward_period-reward_period; --j)
      //   {
      //     if(male.event_by_month[j]>0)
      //     {        
      //       var rew = $('<div class="reward i' + interest[0].class  + '"></div>').appendTo($('.'+male.place+' .treasure .red-carpet'));
      //       rew.css({heigth:th,line_height:th});
      //       rew.css({left: prevPosition - rew.width()/2 + indm*rew.width()+(indm>0?10:0)});
      //       ++indm;
      //     }
      //     if(female.event_by_month[j]>0)
      //     {
      //       var rew = $('<div class="reward i' + interest[0].class  + '"></div>').appendTo($('.'+female.place+' .treasure .red-carpet'));
      //       rew.css({heigth:th,line_height:th});
      //       rew.css({left: prevPosition - rew.width()/2 + indf*rew.width()+(indf>0?10:0)});
      //       ++indf;
      //     }
      //   }
      
